---
title: "myfirst_quarto"
author: "ab"
format: html
editor: visual
---

## my first report using QUARTO for the "Swiss Health-Registry"

In a first part, which I would probably run as a normal R-Script (01_import), I am loading-in my data.

```{r eval=TRUE, echo=FALSE, include=FALSE}

sessionInfo()
#### download if necessary and load the libraries:
pacman::p_load(
  rio,         # import/export
  here,        # file locator
  usethis,
  gitcreds,
  tidyverse,  # collection of packages...
  medicaldata,
  cowplot,
  #Hmisc,
  #ggpmisc,
  renv, # --> lock file with info on environment
  riskCommunicator, # contains data of the Frammingham-Study
  quarto
)
###
# Framingham heart study data
fram <- riskCommunicator::framingham


```

Then I would preprocess (02_preprocess):

```{r eval=TRUE, echo=FALSE, include=FALSE}
#| echo: false
# We keep only the baseline examination data
db <- subset(fram, TIME == 0)

###################### inspect the file
str(db)
head(db)
colnames(db)
tail(db)
summary(db)
######################


#### make the variable sex a factor
#note: I did a quick search in the resources, but do not know if 1=m or 1=f...
# for real data I would need to enquire

# db <- db |>
#   mutate(sex_str = "f") |>
#    mutate(sex_str = replace(sex_str, SEX == 2, "m"))
# table(db$sex_str) 


db$SEX <- factor(db$SEX,
  levels = c(1, 2),
  labels = c("f", "m"))
table(db$SEX)
# I now have a factor which is labelled...
####


###### create department_id 
db$dep_id <- 3


### stable sorting of data:
db <- arrange_all(db)
### the code works, I think it produces the same ordering each time. should be testedâ€¦

row_count <- nrow(db)
print(paste("Number of rows in db:", row_count))
## thank you ChatGTP!
# Identify the indices of every 21th row
indices <- seq(23, row_count, by = 23)
### replace:
db$dep_id[indices] <- 1

### add dep-id no. 2:
indices <- seq(29, row_count, by = 29)
db$dep_id[indices] <- 2
###

# tabulate dep_ids:
#summary(db$dep_id)
table(db$dep_id)


#### generate variable clinic
# will be: 1 "my clinic" vs. 2 "all other clinics"
  
db$clinic <- 2

# a simple replace:
db <- db %>%
  mutate(clinic = if_else(dep_id == 1, 1, clinic))
table(db$clinic)
# are there no easier "replace-functions"?
### I could label my variable clinic here...

# make the variable clinic also a factor:
db$clinic <- factor(db$clinic,
  levels = c(1, 2),
  labels = c("my clinic", "all other clinics"))
table(db$clinic)
# --> this will then used in the table!


####
# ### set all variables to lower script:
# https://www.codingprof.com/how-to-change-the-case-of-column-names-in-r-examples/

### set variable names to lower-case:
names(db) <- tolower(names(db)) # ok... that is not straight-forward
str(db)
###


##### label other variables
# db <- db %>%
#   mutate(sex = case_when(
#     sex == 1 ~ "f",
#     sex == 2 ~ "m",
#     TRUE ~ as.character(sex)  # Retain other values as is
#   ))
str(db)
```

## Table 1.1 for a registry-report (reporting data of the entire registry)

```{r}
#| echo: FALSE
library(gtsummary)
library(dplyr)
db |>
  dplyr::select(sex, age, bmi, cursmoke, prevhyp, diabetes,) |>
  tbl_summary(
    type = all_continuous() ~ "continuous2",
    label = list(age ~ "Age [y]",
                 bmi ~ "BMI [kg/m^2]",
                 cursmoke ~ "currently smoking",
                 prevhyp ~ "Hypertension",
                 diabetes ~ "Diabetes"),
    statistic = all_continuous() ~ c("{mean} ({sd})",
                                     "{median} ({p25}, {p75})",
                                     "{min}, {max}")
  )

```

## Table 1.2 for a hospital-report (reporting data of my clinic vs. all other clinics)

```{r}
#| echo: FALSE
library(gtsummary)

db |>
  dplyr::select(clinic, sex, age, bmi, cursmoke, prevhyp, diabetes,) |>
  tbl_summary(
    by = clinic,
    type = all_continuous() ~ "continuous2",
    label = list(age ~ "Age [y]",
                 bmi ~ "BMI [kg/m^2]",
                 cursmoke ~ "currently smoking",
                 prevhyp ~ "Hypertension",
                 diabetes ~ "Diabetes"),
    statistic = all_continuous() ~ c("{mean} ({sd})",
                                     "{median} ({p25}, {p75})",
                                     "{min}, {max}")
  ) |>
  add_p() # note: added w/o looking into details. Idea: gives hint if there are significant differences
```
This is amazing - the table is a good start, it is produced with a few lines of codes. It would cost me hundreds of lines creating and exporting the same kind of table and graph using STATA...


```{r}
#| echo: FALSE
library(gtsummary)  
# ##### add a density-plot of the variable age:
db |>
  dplyr::select(age,clinic) |>

  ggplot(aes(x = age, fill = clinic)) +
    geom_density(alpha = 0.5) +
    xlab("Age") +
    ylab("Density") +
    ggtitle("Density Plot of Age by Clinic") +
    scale_fill_brewer(palette = "Set2") +
    theme_minimal()


```




## Data exploration

One could now do a t-test for age between the two groups "my clinic" vs. "all other clinics". This is not that interesting... What I will do instead: compare the first quantile in BMI with the last quantile. I will do this for the entire registry and also in the reduced dataset of "my clinic".

## Follows a boxplot

add some text here.

```{r}
#| echo: FALSE

library(dplyr)
library(rstatix)
str(db)
db|>
  mutate(bmi_group = ntile(bmi, 4)) |> ## does it what I expect? i.e. generate  --> should be tested...
  dplyr::filter(bmi_group == 1 | bmi_group == 4) |>
  ggplot(aes(x = as.factor(bmi_group), y = sysbp)) +
  geom_boxplot() +
  xlab("BMI Group") +
  ylab("Systolic blood pressure [mmHg]") +
  ggtitle("Boxplot of BMI in the lowest and highest quartile of bmi")  +
  theme_minimal()

```

## is systolic blood pressure different in the first vs. 4th quartile of bmi?

Since I have high numbers in both groups, it is safe to do a t-test:

```{r}
#| echo: FALSE
table(db$bmi_group)
# if I do this for the entire registry, I am safe, the numbers are high...

### hypothesis: the sysbp is different in the group of the highest and lowest bmi:
#### I am now doing a t-test:

#?t_test

db|>
  mutate(bmi_group = ntile(bmi, 4)) |> ## does it what I expect? i.e. generate  --> should be tested...
  dplyr::filter(bmi_group == 1 | bmi_group == 4) |>
  # Two-samples unpaired test
  #:::::::::::::::::::::::::::::::::::::::::
  t_test(sysbp ~ bmi_group)

```

## Analysis of data of "my clinic"

```{r}
#| echo: FALSE
str(db)
table(db$clinic)

db_clin<- db |>
  dplyr::filter(clinic == "my clinic") |>  # apparently, I have to use the label of the factor...
  mutate(bmi_group = ntile(bmi, 4)) |> ## does it what I expect? i.e. generate quartiles of bmi  --> should be tested...
  dplyr::filter(bmi_group == 1 | bmi_group == 4)
table(db_clin$bmi_group)
str(db_clin)

### now I have a a dataset with lower n..
# --> let's make a histogram across groups

library(ggplot2)
library(dplyr)


db_clin %>%
  ggplot(aes(sysbp)) +
  geom_histogram(bins = 16, alpha=0.5) +
  xlab("Systolic blood pressure [mmHg]") +
  ylab("Count") +
  ggtitle("Histogram of Systolic Blood Pressure") +
  theme_minimal() +
  facet_wrap(~ bmi_group, labeller = labeller(bmi_group = c("1" = "BMI-group 1", "4" = " BMI-group 4"))) +
###

### qqplot
library(ggplot2)
library(dplyr)

db_clin %>%
  ggplot(aes(sample = sysbp)) +
  geom_qq() +
  geom_qq_line(distribution = stats::qnorm) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  ggtitle("QQ Plot of Systolic Blood Pressure") +
  theme_minimal() +
  facet_wrap(~ bmi_group, labeller = labeller(bmi_group = c("1" = "BMI-group 1", "4" = " BMI-group 4")))  
```

```{r}
#| echo: FALSE
### normality-test:
# remember: Ho: normal distribution
db_clin %>%
  shapiro_test(sysbp)

### test: for-loop:
db_clin <- arrange(db_clin, bmi_group)
groups <- unique(db_clin$bmi_group) # this will create a vector. How can I change the order? --> by ordering the data first ;-) 

#groups <- data.frame(groups) # if I wanted a group
counter <- 0
for (group in groups) {
  counter <- counter + 1
  print(paste("Printing group:", group))
  print(paste("Printing counter:", counter))
  
  df_name <- paste("db_clin_", counter, sep = "") # this concatenates
  assign(df_name, db_clin %>% # assigns a value to a name..
           filter(bmi_group == group))
  # Perform Shapiro-Wilk test on sysbp variable for each data frame
  shapiro_result <- shapiro_test(get(df_name)$sysbp)
  print(paste("Shapiro-Wilk test result for", df_name))
  print(shapiro_result)
}  
# --> since the p-value of one group and both groups together is not in agreement with the H0, I will now perform a non-parametric test.

db_clin %>%
  wilcox_test(sysbp ~ bmi_group)
  
```
add some text here

```{r}
#| echo: false
################################# render #################################
#quarto::quarto_render("R/quarto/01_registry_hospital_report.Rmd")
#have a look at it!
```

## Questions

-   Assuming I wanted to create a benchmark report for all my clinics (my clinic vs. Pool) --\> How would I organize my work? -master-file, invoking:

1)  r-script: data-import
2)  r-script: preprocessing of data then: loop over all departments and\
    3)r-script: analysis - graphs
3)  quarto-script: publish report (as xml, pdf, )
